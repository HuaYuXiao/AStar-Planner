% %main
% %�ϰ���Ŀ�꣬��ʼλ�ö���֪��·���滮,��ͼʵ�ִ������Թ滮��һ���ܿ��ϰ�����Ŀ���·����
% %��ʼ�����Ĳ���
% clear all;
% Xo=[0 0];%起点位置
% k=15;%计算引力需要的增益系数
% K=0;%初始化
% m=5;%计算斥力的增益系数，都是自己设定的.
% Po=3;%障碍影响距离，当障碍和车的距离大于这个距离时，斥力为0，即不受该障碍的影响。也是自己设定。
% n=7;%障碍个数
% a=0.5;
% l=0.2;%步长
% J=200;%循环迭代次数
% %如果不能实现预期目标，可能也与初始的增益系数，Po设置的不合适有关。
% %end
% %给出障碍和目标信息
% Xsum=[10 10;1 1.2;3 2.5;4 4.5;3 6;6 2;5.5 5.5;8 8.5];%这个向量是(n+1)*2维，其中[10 10]是目标位置，剩下的都是障碍的位置。
% Xj=Xo;%j=1循环初始，将车的起始坐标赋给Xj
% %***************��ʼ������ʼ����ѭ��******************
% for j=1:J%ѭ����ʼ
%     Goal(j,1)=Xj(1)%Goal�Ǳ��泵�߹��ÿ�������ꡣ�տ�ʼ�Ƚ����Ž��������
%     Goal(j,2)=Xj(2)
% %���ü���Ƕ�ģ��
%    Theta=compute_angle(Xj,Xsum,n)%Theta�Ǽ�������ĳ����ϰ�����Ŀ��֮�����X��֮��ļнǣ�ͳһ�涨�Ƕ�Ϊ��ʱ�뷽�������ģ����Լ��������
% %���ü�������ģ��
%    Angle=Theta(1)%Theta��1���ǳ���Ŀ��֮��ĽǶȣ�Ŀ��Գ���������
%    angle_at=Theta(1)%Ϊ�˺�������������������ķ�����ֵ��angle_at
%    [Fatx,Faty]=compute_Attract(Xj,Xsum,k,Angle)%�����Ŀ��Գ���������x,y�������������ֵ��
%    %for i=1:n
%     %if i==1
%      %   Fatxx(i)=Fatx
%       %  Fatyy(i)=Faty
%       %else
%       %  Fatxx(i)=0
%        % Fatyy(i)=0
%        %end
%        %end%���ѭ����Ϊ�˽���������������ֵ��չ���������ͺ���ĳ�������ʱ������ά����ͬ��
% %end
%     for i=1:n
%        angle_re(i)=Theta(i+1)%��������õĽǶȣ��Ǹ���������Ϊ��n���ϰ�������n���Ƕȡ�
%      end
% %���ü������ģ��
%     [Frerxx,Freryy,Fataxx,Fatayy]=compute_repulsion(Xj,Xsum,m,angle_at,angle_re,n,Po)%�����������x,y����ķ������顣
%  %��������ͷ����������⣬Ӧ������ÿ��jѭ����ʱ������Ĵ�СӦ����һ��Ψһ���������顣Ӧ�ðѳ��������з�����ӣ��������з�����ӡ�
%     Fsumyj=Faty+Freryy+Fatayy%y����ĺ���
%     Fsumxj=Fatx+Frerxx+Fataxx%x����ĺ���
%     Position_angle(j)=atan(Fsumyj/Fsumxj)%������x�᷽��ļн�����
% %���㳵����һ��λ��
%     Xnext(1)=Xj(1)+l*cos(Position_angle(j))
%     Xnext(2)=Xj(2)+l*sin(Position_angle(j))
%     %���泵��ÿһ��λ����������
%     Xj=Xnext
%     %�ж�
%     if (abs(Xj(1)-Xsum(1,1))<0.1)&(abs(Xj(2)-Xsum(1,2))<0.1)%��Ӧ����ȫ��ȵ�ʱ�������������ֻ�ǽӽ�Ϳ��ԣ����ڰ���ȫ��ȵ�ʱ���̡�
%        K=j%��¼�����ٴΣ�����Ŀ�ꡣ
%        break;
%        %��¼��ʱ��jֵ
%     end%�����if�����������·���ѭ��������ִ�С�
% end%��ѭ������
% K=j;
% Goal(K,1)=Xsum(1,1);%把路径向量的最后一个点赋值为目标
% Goal(K,2)=Xsum(1,2);
% %***********************************画出障碍，起点，目标，路径点*************************
% %画出路径
% X=Goal(:,1);
% Y=Goal(:,2);
% 
% %路径向量Goal是二维数组,X,Y分别是数组的x,y元素的集合，是两个一维数组。
% x=[1 3 4 3 6 5.5 8];%障碍的x坐标
% y=[1.2 2.5 4.5 6 2 5.5 8.5];
% figure;
% plot(x,y,'o',10,10,'v',0,0,'ms',X,Y,'.r');


%main
%障碍和目标，起始位置都已知的路径规划,意图实现从起点可以规划出一条避开障碍到达目标的路径。
%初始化车的参数
clear all;
Xo=[0 0];%起点位置
k=30;%计算引力需要的增益系数
K=0;%初始化
m=15;%计算斥力的增益系数，都是自己设定的.
Po=5.5;% 5.5障碍影响距离，当障碍和车的距离大于这个距离时，斥力为0，即不受该障碍的影响。也是自己设定。
n=7;%障碍个数
a=0.5;
l=0.2;%步长
J=200;%循环迭代次数
C=0;
d=0;
%如果不能实现预期目标，可能也与初始的增益系数，Po设置的不合适有关。
%end
%给出障碍和目标信息
Xob=unifrnd (1, 10, 7, 2)
% Xsum=[10 10;Xob];
Xsum=[10 10;1 1.2;3 2.5;4 4.5;3 6;6 2;5.5 5.5;8 8.5];%这个向量是(n+1)*2维，其中[10 10]是目标位置，剩下的都是障碍的位置。
Xj=Xo;%j=1循环初始，将车的起始坐标赋给Xj
%***************初始化结束，开始主体循环******************
for j=1:J%循环开始
    Goal(j,1)=Xj(1);%Goal是保存车走过的每个点的坐标。刚开始先将起点放进该向量。
    Goal(j,2)=Xj(2);
%调用计算角度模块
   Theta=compute_angle(Xj,Xsum,n);%Theta是计算出来的车和障碍，和目标之间的与X轴之间的夹角，统一规定角度为逆时针方向，用这个模块可以计算出来。
%调用计算引力模块
   Angle=Theta(1);%Theta（1）是车和目标之间的角度，目标对车是引力。
   angle_at=Theta(1);%为了后续计算斥力在引力方向的分量赋值给angle_at
   [Fatx,Faty]=compute_Attract(Xj,Xsum,k,Angle);%计算出目标对车的引力在x,y方向的两个分量值。
   
    for i=1:n
       angle_re(i)=Theta(i+1);%计算斥力用的角度，是个向量，因为有n个障碍，就有n个角度。
    end
%调用计算斥力模块
    [Frerxx,Freryy,Fataxx,Fatayy]=compute_repulsion(Xj,Xsum,m,angle_at,angle_re,n,Po,a);%计算出斥力在x,y方向的分量数组。
%计算合力和方向，这有问题，应该是数，每个j循环的时候合力的大小应该是一个唯一的数，不是数组。应该把斥力的所有分量相加，引力所有分量相加。
    Fsumyj=Faty+Freryy+Fatayy;%y方向的合力
    Fsumxj=Fatx+Frerxx+Fataxx;%x方向的合力
    Position_angle(j)=atan(Fsumyj/Fsumxj);%合力与x轴方向的夹角向量
%计算车的下一步位置
    Xnext(1)=Xj(1)+l*cos(Position_angle(j));
    Xnext(2)=Xj(2)+l*sin(Position_angle(j));
    %保存车的每一个位置在向量中
    Xj=Xnext;
    %判断
    if (abs(Xj(1)-Xsum(1,1))<0.1)&(abs(Xj(2)-Xsum(1,2))<0.1)%是应该完全相等的时候算作到达，还是只是接近就可以？现在按完全相等的时候编程。
       K=j;%记录迭代到多少次，到达目标。
       disp('arrived  ');
       disp(K);
       break;
       %记录此时的j值
    end%如果不符合if的条件，重新返回循环，继续执行。
    % C=C+(Goal(j,1)-Xnext(1))^2+(Goal(j,2)-Xnext(2))^2;
end%大循环结束
K=j;
Goal(K+1,1)=Xj(1);%把路径向量的最后一个点赋值为目标
Goal(K+1,2)=Xj(2);
% Goal(K+2,1)=Xsum(1,1);%把路径向量的最后一个点赋值为目标
% Goal(K+2,2)=Xsum(1,2);
%***********************************画出障碍，起点，目标，路径点*************************
%画出路径
X=Goal(:,1);
Y=Goal(:,2);

%路径向量Goal是二维数组,X,Y分别是数组的x,y元素的集合，是两个一维数组。
x=[1 3 4 3 6 5.5 8];%障碍的x坐标
y=[1.2 2.5 4.5 6 2 5.5 8.5];
figure;

plot(x,y,'o',10,10,'v',0,0,'ms',X,Y,'.r');
title({'plot',['引力系数  ',num2str(k),' 斥力系数  ',num2str(m),' 障碍影响距离  ',num2str(Po)]});

